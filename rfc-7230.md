### RFC 7230 Hypertext Transfer Protocol \(HTTP/1.1\): Message Syntax and Routing

### 概述
超文本传输协议（HTTP）是一个无状态的应用级的协议，用于分发，合作，超文本信息系统。这个文档提供了 HTTP 架构的概述和它关联的术语，定义了“http”和“https”统一资源标识符（URI）方案，描述了实现相关的安全考虑。

### 这个备忘录的状态
这是一个网络标准跟踪文档。

这个文档是互联网工程任务组（IETF）的产品。它表示了 IETF 社区的一致意见。它接收了公共的审查，并已经被网络工程指导小组（IESG）批准发布。更多关于网络标准的信息可以在 RFC 5741 章节 2 获取。

这个文档当前的状态信息，任何勘误，和如何提供关于它的反馈可以在 [http://www.rfc-editor.org/info/rfc7230](http://www.rfc-editor.org/info/rfc7230) 获取。

### 版权注意
待续表示


### 1. 介绍

超文本转移协议（HTTP）是一个无状态的应用级请求/响应协议，使用可扩展的语义和自描述的信息负载和基于网络的超文本信息系统灵活交互。这个文档是构成 HTTP/1.1 的一系列文档中的第一个。

1. “消息语法和路由（Message Syntax and Routing）”（这个文档）
2. “语义和内容（Sematics and Content）”[RFC7231]
3. “条件请求（Conditional Requests）”[RFC7232]
4. “范围请求（Range Requests）”[RFC7233]
5. “缓存（Caching）”[RFC7234]
6. “认证（Authentication）”[RFC7235]

这个 HTTP/1.1 规格废弃了 RFC 2616 和 RFC 2145（在 HTTP 版本上）。这个规格也更新了使用 CONNECT 去建立一个隧道，之前定义在 RFC 2817，并定义了信息描述在 RFC 2818 的“https” URL 方案。

HTTP 对于信息系统来说是一个通用的接口协议。它设计是为了通过提供一个资源类型无关的通用接口给客户端来隐藏一个服务如何实现。同样的，服务端不需要知道每个客户端的意图：一个 HTTP 请求可以看作是独立的，而不是和特定类型的客户端关联或者预先定义的应用步骤。结果是一个协议可以有效的用在不同的上下文，它的实现可以随着时间独立发展。

HTTP 也设计用于中间人协议，和非 HTTP 信息系统传输交流。HTTP 代理和网关可以通过转化各种协议到超文本格式提供对可替代信息服务的访问，它可以被客户端以和 HTTP 服务相同的方式查看和操作。

这种灵活性的一个结果就是协议无法用术语定义接口背后发生了什么。作为替代，我们有限的定义了交流的语法，收到交流的意图，和接收者的预期行为。如果交流被认为是独立的，则成功的操作应该在服务提供的可观察的接口反应出适当的改变。然而，因为许多客户端可能同步操作并且可能目标不同，我们不能要求这些超出单个响应的改变可以被观察。

这个文档描述了 HTTP 使用或者引用的架构元素，定义了“http”和“https”URI 方案，描述了整个网路操作和连接管理，并定义了 HTTP 消息帧和转发要求。我们的目标是定义 HTTP 消息处理必须的机制，独立于消息语义，因此定义了完整的消息转化需求集合和信息转发中间人。

### 1.1 需求表达
在这个文档中的关键字“必须（MUST）”，“必须不（MUST NOT）”，“需要（REQUIRED）”，“应该（SHALL）”，“应该不（SHALL NOT）”，“应该（SHOULD）”，“应该不（SHOULD NOT）”，“推荐（RECOMMENED）”，“MAY（可能）”，“可选（OPTIONAL）”将按照 RFC2119 中的描述解释。
### 1.2 语法表示
这个规格使用 RFC5234 中增强的巴克斯范式（ABNF）符号和一个列表增强表示，定义在章节7，它允许使用‘#’操作符紧凑定义都好分割的列表（就像‘*’操作符指示重复）。附录 B 显示了扩展标准 ABNF 符号的所有列表操作符集合语法。

下面核心规则通过引用包含，就像定义在 RFC5234，附录 B.1：ALPHA（字母），CR（回车），CRLF（CR LF），CRL（control），DIGIT（数字0-9），DQUOTE（双引号），HEXDIG（16进制 0-9/A-F/a-f），HTAB（水平制表符），LF（换行），OCTET（任何 8 比特数据序列），SP（空格），和 VCHAR（任何可见的 USASCII 字符）

按照惯例，ABNF 规则名添加“obs-”前缀表示“废弃”语法规则，因为历史原因出现。

### 2. 架构
HTTP 为万维网（WWW）架构创建，并为支持世界范围的超文本系统的伸缩性需求随着时间进化。
### 2.1 客户端/服务端信息
HTTP 是无状态的请求/响应协议，通过在可信赖的传输或者会话层“连接”（章节6）交换信息（章节 3）操作。一个 HTTP “客户端”是一个为了发送一个或多个请求，建立到服务端的连接的程序。HTTP “服务端”是一个通过发送 HTTP 响应为了服务 HTTP 请求接受连接的程序。

术语“客户端（client）”和“服务端（server）”指的只是这些程序为特定连接执行的角色。相同的程序可能在某些连接表现的像一个客户端，而某些连写表示的像服务端。术语“用户代理（user agent）”指的只是许多初始化一个请求的程序，包括（但是不限于）浏览器，爬虫（基于网络的机器人），命令行工具，自定义应用，和手机应用。术语“原始服务器（origin server）”指的是可以为指定资源发起权威性响应的程序。术语“发送者（sender）”和“接收者（recipient）”分别指的是发送或者接受给定信息的任何实现。

HTTP 依赖统一资源标识符（URI）标准 RFC3986 去指示目标资源 章节 5.1 和资源之间的关系。消息通过类似于互联网邮件 RFC5322 和多目标互联网邮件扩展（MIME）RFC2045（查看 RFC7231 的附录 A 了解 HTTP 和 MIME 消息的不同）。

大部分 HTTP 通信好汉一个获取请求（GET），用于表示 URI 定义的一些请求。在最简单的场景中，这可能通过在用户代理（UA）和原始服务器（O）之间单个双向的连接（===）完成。
```
        request     >
    UA =================================== O
                            < response
```

客户端以请求消息的形式发送一个 HTTP 请求到服务器，以包含一个方法，URI，和协议版本的请求行开始（章节 3.1.1），跟随着头部域，包含请求定义，客户端信息，和元数据表示（章节 3.2），一个空行指示头部章节的结束，最后一个消息体包含负载体（如果有，章节 3.3）。

一个服务端通过发送一个或者多个 HTTP 响应信息响应客户端请求，每一个以包含协议版本，一个成功或者错误的码，和文字的原因语句的状态行为开始（章节 3.1.2），可能跟随着头部域，包含服务端信息，资源元数据，和元数据表示（章节3.2），一个空行表示头部章节的结束，最后是一个包含负载体的消息体（如果存在，章节 3.3）

一个章节可能用于多个请求/响应交换，定义在章节 6.3。

下面的栗子绘制一个在 URI “http://www.example.com/hello.txt”上的 GET  请求典型信息交换：

客户端请求：
```
    GET /hello.txt HTTP/1.1
    User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.71 zlin/1.2.3
    Host: www.example.com
    Accept-Language: en, mi
```
服务端响应：
```
    HTTP/1.1 200 OK
    Date: Mon, 27 Jul 2009 12:28:53 GMT
    Server: Apache
    Last-Modified: Web, 22 Jul 2009 19:15:56 GMT
    ETag: "34aa387-d-1568eb00"
    Accept-Range: bytes
    Content-Length: 51
    Vary: Accept-Encoding
    Content-Type: text/plain

    Hello World! My payload includes a trailing CRLF.
```

### 2.2 实现多样性
当考虑 HTTP 的设计的时候，很容易落入一个陷阱，认为所有的用户代理都是通用目的的浏览器，所有的源服务器都是巨大的公共网站。实际情况并非如此。常见用户代理包含家用器具，立体声，天平，固件升级脚本，命令行程序，移动应用，和在多种形状和大小的通信设备。同样的，常见 HTTP 源服务器包含家用自动单元，可配置的网路哦组件，办公机器，自动化机器人，新闻流，交通照相机，广告选择器，和视频分发平台。

术语“用户代理（user agent）”不意味着在请求的时候有一个人类用户直接交互的软件代理。在很多场景中，一个用户代理被安装或者被配置去在后台运行，保存结果为了接下来的检查（或者只保存这些结果的子集合，可能是感兴趣的或者错误的）。爬虫，比如，通常给定一个开始 URI，并配置爬取网页作为超文本图的确定行为。

HTTP 实现的多样性意味着并使所有的用户代理可以给他们的用户提出互动建议，或者提供足够的安全或者隐私问题警告。在很少的场景中，这个规格需要报告错误给用户，这些报告只能在错误控制台或者日志文件可以观察是可以接受的。同样的，在处理之前被用户处确认的自动动作可能通过高级配置选项，运行时选项或者简单的回避不安全动作可以遇见；确认并不意味着指定的用户接口或者普通处理终端如果用户已经且人了选项。

### 2.3 中介
HTTP 允许使用中介去满足请求，通过一系列的连接。有三种常形式的 HTTP 中介：代理，网关和隧道。在某些场景中，一个单独的中介可能表现为一个源服务端，代理，网关，或者隧道，基于每个请求的行为切换行为
```
        >           >           >           >
    UA ========= A ========= B ========= C ========= O
              <           <           <           <
```
上面的图像显示 3 个在用户代理和源服务端之间的中介（A，B，和 C）。一个请求或者响应的信息哦你给过 4 个分离的连接在整个链中传输。一些 HTTP 交流选项可能只接受连接最近的，没有隧道的邻居，或者链的终点，或者链中的所有连接。尽管图像是先行的，每一个部分可能参与多个，同步的交流。比如，B 可能从 A 之外的许多客户端接受请求，并且/或者转发请求到除了 C 之外的服务端，同时还处理 A 的请求。同样的，后面的请求可能通过不同的连接路径发送，经常基于均衡代理动态配置。

术语“上行流（upstream）”和“下行流（downstream）”用来描述消息流相关的定向需求：所有的消息从上行流到下行流。术语“入站（inbound）”和“出站（outbound）”用来描述请求如喽相关的定向需求：“入站（inbound）”意味着朝着服务端“出站（outbound）”意味着朝着用户代理。

一个“代理（proxy）”是一个用户代理选择的信息转发代理，通常通过本地配置规则，去接受一些类型的绝对 URI 的请求并尝试通过 HTTP 接口转化去满足这些请求。一些请求是非常小的，比如为“http” URI的代理请求，然而其他请求可能需要转化为完全不同的应用等级的协议。代理通常用来分组一个组织的 HTTP 请求，通过一个常见的中介为了安全起见，注释服务，或者缓存分享。一些代理设计用于被转发接受转化为选中的消息或者负载，描述在章节 5.7.2。

所有应用于源服务端的的 HTTP 需求对于网关的出站交流都适用。一个网关和入站服务的交流使用任何他渴望的协议，包括不再这个规格内的私有的 HTTP 扩展。然而，一个 HTTP 到 HTTP 的网关和第三方 HTTP 服务交互的时候网关入站连接应该符合用户代理需求。

一个“隧道（tunnel）”在两个连接之间表现的像不修改信息的忙转发。一旦激活，一个隧道不被认为是 HTTP 会话的一部分，尽管隧道可能通过一个 HTTP 请求初始化，一个隧道在依赖的连接双端都关闭的时候停止。隧道用来通过一个中介扩展一个虚拟连接，比如当传输层安全（TLS，RFC5246）用来建立秘密会话，通过一个分享的防火墙代理。

上面分类的中介只被认为这些表现为 HTTP 会话的参与者。还有一些中介可以在更低层次的网路协议栈行动，过滤或者重定向 HTTP 交通，不需要消息发送者的知识或者权限。网络中介是和中间人攻击是难以区分的，常常引入安全缺陷或者互通性问题，因为错误的验证 HTTP 语义。

比如，一个“拦截代理（interception proxy）” [RFC3040]（也称为“透明代理transparent proxy” [RFC1919] 或者“强制门户（captive portal）”）和 HTTP 代理是不同的，因为他不是通过客户端选择的。作为替代，一个拦截代理过滤或者重定向出去的 TCP 端口 80 包（偶尔还有其他的端口交通）。拦截代理通常可以在公共网络受理点可以找到，作为强制账户先订阅蔡恩感允许使用非本地互联网服务的手段，在企业防火墙内实施网络使用策略。

HTTP 定义为无状态的协议，意味着每一个请求消息可以独立的理解。每一个依赖于 HTTP 无状态设计的实现为了重用代理连接或者动态负载均衡请求创月镀铬服务器。因此，一个服务但必须不假设两个在同一个连接的请求是从同一个用户代理来的，除非连接是安全的并且是代理指定的。一些非标准的 HTTP 扩展（比如，[RFC4559]）违反了这些要求，导致安全和互操作性问题。



### 2.4 缓存

一个“缓存（cache）”是一个缓存之前响应信息的本地存储，控制它的信息存储，获取，和删除的子系统。一个缓存存储可以缓存的响应，为了减少响应时间和未来的网络频率损耗，相当于请求。任何客户端或者服务端可能晴空缓存，尽管当表现为一个隧道时候一个缓存不能被服务端使用。

缓存的效果是缩短请求/响应的链，如果链中的参与者对于请求有缓存的响应。下面绘制了一个请求如果 B 有一个上一次请求 O（通过 C）的响应的缓存副本，没有被 UA 或者 A 缓存的结果。
```
        >       >
    UA ====== A ====== B ------ C ----- O
            <        <
```
一个响应是“可缓存的（cacheable）”如果一个缓存被允许存储一个响应信息的副本，用来会因接下来序列的请求。当一个响应可缓存的时候，缓存的响应在用于特定的请求的时候，客户端或者服务端还可能存在额外的限制。缓存行为和可缓存响应的 HTTP 要求定义在 [RFC7234] 的章节 2。

有各种各样架构和配置的缓存部署跨域万维网和巨大组织内部。包括国家级别的代理缓存，为了节约跨洋带宽，广播或者多播缓存条目的协作系统，打包预获取缓存条目在离线或者高延迟环境使用，等等。


### 2.5 一致性和错误处理

### 2.6 协议版本
HTTP 使用一个“<major>.<monor>”数字方案去指定协议的版本。这个规格定义了版本“1.1”。协议版本指示发送者是否满足这个 HTTP 版本的规格的一系列需求。

一个 HTTP 消息的版本是通过消息的第一行的 HTTP 版本域指定的。HTTP 版本是大小写敏感的
```
    HTTP-version    = HTTP-name "/" DIGIT "." DIGIT
    HTTP-name       = %x48.54.54.50 ; "HTTP", 大小写敏感
```
HTTP 版本数字由两个小数数字组成，使用“.”分离（句点或者小数点）。第一个数字（“主版本”）指示信息的语法，第二个数字（“次版本”）指示发送者在接下来的会话中能够理解的主版本的最高次版本。次版本说明发送者交流能力，就算发送者只使用向后兼容的协议子集，因此让接收者知道更多高级特性可以在响应中使用（通过服务）或者在接下来的请求（通过客户端）。

当一个 HTTP/1.1 信息被发送到一个 HTTP/1.0 接收者[RFC1945] 或者一个接收者的版本位置，HTTP/1.1 消息的构造允许他被解析为一个有效的 HTTP/1.1 消息，如果忽略所有的新功能。这个规格将接收者版本需求放在某些新功能上，这样一个一致的发送者只使用兼容的功能，直到它被决定，通过配置或者消息的收据，接收者支持 HTTP/1.1。

一个头部域的解释在相同主要 HTTP 版本的次要版本之间应该相同，尽管一个接收者在这些域缺省的时候的默认行为可以改变。除非指定，否则定义在 HTTP/1.1 定义的头部域是为所有的 HTTP/1.x 版本定义的，特别是，Host 和 Connection 头部域应该被所有的 HTTP/1.x 实现者实现，不管他们是否旋床兼容 HTTP/1.1。

新的头部域可以引入而不改变协议版本，如果他们定义的语法允许他们安全的被接收者忽略而不认出他们。头部域的扩展在章节 3.2.1 讨论。

处理 HTTP 消息的中介（比如，所有不表现为隧道的中介）必须在转发的消息中发送他们自己的 HTTP 版本。换句话说，不允许去盲转发 HTTP 消息的第一行，在没有确认消息中协议的版本匹配和接收者和发送者的版本兼容。转发一个 HTTP 消息没有重写 HTTP 版本可能会导致交流错误当下行流接收者使用信息发送者版本去决定那些功能在接下来和发送者的绘画中是安全的。

一个客户端应该发送一个和客户端版本兼容最高版本的请求，他的祝版本没有比服务端支持的最高版本高。一个客户端必须不发送一个他不兼容的版本。

一个客户端可能发送一个低请求版本，如果他知道服务端不正确的实现了 HTTP 规格，但是只有在客户端至少尝试一个正常请求并从响应状态码或者头部域（比如，Server）决定服务端不适合处理高请求版本。

一个服务端应该发送一个响应版本等于或者大于服务端兼容版本，它的主版本小于或者等于请求接收到的。一个服务端可以发送一个 505（HTTP 版本不支持）响应如果它希望，因为一些原因，去拒绝服务客户端的主协议版本。

一个服务端可能发送 HTTP/1.0 响应给一个请求，如果他知道或者推测客户端不正确的实现了 HTTP 规格，并且无法正确的处理接下来版本的响应，比如当一个客户端转化版本数失败或者当一个中介盲转化 HTTP 版本，当它不兼容给定的次版本协议。协议降级应该不执行除非触发特定客户端属性，比如当一个或者多个头部域（比如，User-Agent）唯一命中客户端发送的只是一个错误。

HTTP 版本设计的目的是只有在不兼容的消息语法被引入的时候才增加主版本号。此版本号只有在改变让协议又增加信息语法的效果或者暗示发送者有额外的能力。然而，此版本号从 [RFC2068] 到 [RFC2616] 都没有增加过，这个修改特意避免对协议产生任何这类的改变。

当一个 HTTP 消息被一个主版本号被接收者实现，但是次版本号比接收者高的时候，接收者应该以接收者主版本中接收者兼容的最高次版本一样处理这个消息。一个接收者可以假设一个来自高次版本的消息发送给一个不支持更高版本的发送者的时候，是足够向后兼容的，可以被任何主版本的实现安全的处理。

### 2.7 统一资源标识符

统一资源标识符（URI）[RFC3986] 贯穿 HTTP，用来标识资源（[RFC7231 章节2]）。URI 引用用来标识目标请求，指示重定向，定义关系。

“URI 引用（URI-引用）”，“绝对 URI（absolute-URI）”，“相对部分（relative-part）”，“方案（schema）”，“认证（authority）”，“端口（port）”，“主机（host）”，“可空路径（path-abempty）”，“部分（segment）”，“查询（query）”，“片段（segment）”的定义来自 URI 通用语法。“绝对路径（absolute-path）”规则是为协议元素定义的，包含一个非空的路径组件。（这个规则和 RFC 3986 的可空路径有点不同，它允许一个空路径在引用中使用，绝对路径规则，不允许以“//”开始）。一个"部分 URI（partial-URI）"规则是为协议元素定义的，可以包含一个相对 URI 但是不包含片段组件。

```
    URI-reference   = <URI-reference 查阅 [RFC3986] 章节 4.1>
    absolute-URI   = <absolute-URI 查阅 [RFC3986] 章节 4.1>
    relative-part   = <relative-part 查阅 [RFC3986] 章节 4.1>
    schema   = <schema 查阅 [RFC3986] 章节 4.1>
    authority   = <authrigy 查阅 [RFC3986] 章节 4.1>
    uri-host   = <host 查阅 [RFC3986] 章节 4.1>
    port   = <port 查阅 [RFC3986] 章节 4.1>
    path-abempty   = <port 查阅 [RFC3986] 章节 4.1>
    segment   = <segment 查阅 [RFC3986] 章节 4.1>
    query   = <query 查阅 [RFC3986] 章节 4.1>
    fragment   = <fragment 查阅 [RFC3986] 章节 4.1>
```
HTTP 中的每一个允许 URI 引用的协议元素都将在它的 ABNF 产生式中指定该元素允许的引用格式（URI 引用），只有绝对格式的 URI（absolute-URI），只有路径和可选的查询组件，或者前面的组合。除非有其他指定，URI 引用转化为有效的请求 URI（章节 5.5）

### 2.7.1 http URI 方案

在这里定义 “http” URI 方案是为了铸造一个标识符，基于他们关联的层级命名空间，被潜在的 HTTP 服务管理，该服务在给定端口监听 TCP（[RFC0793]）连接。
```
    http-URI    = "http:" "//" authority parh-abempty [ "?" query] [ "#" fragment ]
```

一个 “http” 源服务通过认证组件定义，包含一个主机标识符和一个可选的 TCP 端口（[RFC3986]，章节 3.2.2）。层级路径组件和可选的查询组件作为潜在目标资源的标识符。可选的片段组件允许间接指定次级资源，不依赖 URI 方案，定义在 [RFC3986] 的章节 3.5。

一个发送者必须不生成一个空主机标识符的“http” URI。一个处理这类 URI 引用的接收者必须拒绝他就像不合法。

如果提供的主机标识符是一个 IP 地址，源服务器是该 IP 地址指定 TCP 端口的监听者。如果主机是一个注册的名字，注册的名字是一个间接标识符，使用名字解析方案，比如 DNS，找出一个源服务的地址。如果端口子组件是空的或者并未给出，默认 TCP 端口是 80（WWW 服务保留端口）。

注意，一个有给定认证组件的 URI 存在并不暗示这总是有一个 HTTP 服务在主机和端口监听连接。任何人可以铸造一个 URI。决定一个认证组件的是谁正确的对目标标识资源进行权威响应。注册名称的代理性质委托和 IP 地址创建一个联合命名空间，通过控制主机和端口的指定，不论一个 HTTP 服务是否存在。查阅章节 9.1 了解创建认证的安全考虑。

当一个“http” URI 在访问指定资源的上下文使用的时候，一个客户端可能尝试访问将主机转化为 IP 地址。建立一个 TCP 连接到这个指定端口的地址。并发送一个 HTTP 请求消息（章节3）包含 URI 的表示数据（章节5）到服务端。如果服务不是使用一个临时的 HTTP 响应消息响应请求，在 [RFC7231] 的章节6描述，则这个响应被认为客户端的请求的权威响应。

尽管 HTTP 是独立于传输协议的，“http”方案对基于 TCP 服务是特殊的，因为名字代理处理依赖 TCP 建立认证。一个 HTTP 服务基于一些其他底层连接协议大概会标识一个不同的 URI 方案，比如“https”方案（下面）用于需要端对端安全连接的资源。其他协议可能也用来提供对“http”标识资源的访问 -- 只有专门用于 TCP 的全文接口。

权威的 URI 通用语法也包含一个不推荐的用户信息子组件（[RFC3986]，章节 3.2.1），用来在 URI 中包含用户认证信息。一些实现在内部认证信息的配置使用用户信息组件，比如在命令调用选项，配置文件，或者书签列表，尽管这么使用可能暴露用户标识或者密码。一个发送者必须不生成用户细腻子组件（和它的“@”定界符），当一个“http" URI 引用在作为请求目标的信息内生成或者头部域的值。在使用一个来自不信任的源的”http" URI 引用的时候，一个接收者应该转化用户信息，并当作一个错误；它很有可能用来掩盖钓鱼工具。

### 2.7.2 https URI 方案
这里定义的 “https” URI 方案是为了铸造标识符，基于他们关联的层级命名空间，被潜在的 HTTP 源服务管理，它们为了 TLS 安全链接监听给定的 TCP 端口。

列在上面的所有“http”方案的要求对“https”方案都适用，除了 TCP 端口 443 是端口子组件默认值，如果该组件是空或者没有给定，用户代理必须保证它和服务端的链接是安全的，通过适用抢加密，端对端，在发送第一个 HTTP 请求之前。
```
    https-URI = "https:" "//" authority path-abempty [ "?" query ] [ "#" fragment ]
```
注意“https” URI 方案依赖于 TLS 和 TCP 建立认证。通过“https”方案访问的资源不能和“http”方案分享，就算他们资源标识符指定相同的认证（相同的主机监听相同的 TCP 端口）。他们是不同的命名空间并且被认为和源服务器不同。然而，一个 HTTP 的扩展定义应用于整个主机域名，比如 Cookie 协议 [RFC6265]，允许信息通过一个服务设置，这暗示和其他服务的交流在同一个主机域内。

权威访问一个“https”表示的资源的处理流程定义在 [RFC
2818]。


### 2.7.3 http 和 https URI 规范化和比较

因为“http”和“https”方案和 URI 通用语法一致，这些 URI 基于定义在 [RFC 3986] 的章节 6 的算法标准化和比较，使用前面每个方案的默认描述。

如果端口和一个方案的默认端口相同，普通格式是缺省端口子组件。当不再绝对格式中用作一个 OPTION 请求的请求目标，一个空的路径组件和“/”绝对路径相等，所以，普通格式是提供一个“/”替代。方案和主机是大小写不敏感的，通常使用小写；所有其他组件以大小写敏感方式比较。除了“保留”集合中的字符外，其他字符和他们的百分比编码八位字节相同：普通格式是不编码他们（查看[RFC3986]的章节 2.1 和 2.2）

比如，下面 3 个 URI 是相等的：
```
    http://example.com:80/~smith/home.html
    http://EXAMPLE.com/%7Esmith/home.html
    http://EXAMPLE.com:/%7esmith/home.html
```

### 3. 信息格式
### 3.1 开始行
### 3.1.1 请求行
### 3.1.2 状态行
### 3.2 头部域
### 3.2.1 域扩展性
### 3.2.2 域顺序
### 3.2.3 空格
### 3.2.4 域转化
### 3.2.5 域限制
### 3.2.6 域值组件
### 3.3 消息体
### 3.3.1 传输编码
### 3.3.2 内容长度
### 3.3.3 消息体长度
### 3.4 处理不完整的信息
### 3.5 消息转化鲁棒性

### 4. 传输编码
### 4.1 分块传输编码
### 4.1.1 分块扩展
### 4.1.2 分块尾挂部分
### 4.1.3 分块解码
### 4.2 压缩编码
### 4.2.1 Compress 编码
### 4.2.2 Deflate 编码
### 4.2.3 Gzip 编码
### 4.3 TE
### 4.4 Trailer


### 5. 信息路由
### 5.1 标识一个目标资源
### 5.2 连接入站
### 5.3 请求目标
### 5.3.1 来源格式
### 5.3.2 绝对格式
### 5.3.3 认证格式
### 5.3.4 通配格式
### 5.4 主机
### 5.5 有效的请求 URI
### 5.6 关联一个响应到请求
### 5.7 信息转发
### 5.7.1 通过
### 5.7.2 转发


### 6. 链接管理
### 6.1 连接
### 6.2 建立
### 6.3 持久化
### 6.3.1 重试请求
### 6.3.2 管道
### 6.4 并发
### 6.5 失败和超时
### 6.6 断开
### 6.7 升级

### 7. ABNF 列表扩展：#rule


### 8. IANA 考虑
### 8.1 头部域注册
### 8.2 URI 方案注册
### 8.3 互联网媒体类型注册
### 8.3.1 互联网媒体类型信息/http
### 8.3.2 互联网媒体类型应用/http
### 8.4 传输编码注册
### 8.4.1 程序
### 8.4.2 注册
### 8.5 内容编码注册
### 8.6 升级令牌注册
### 8.6.1 程序
### 8.6.2 升级令牌注册

### 9. 安全考虑
### 9.1 建立认证
### 9.2 中间人风险
### 9.3 通过协议元素长度攻击
### 9.4 响应分割
### 9.5 请求走私
### 9.6 消息完整性
### 9.7 消息机密性
### 9.8 服务器日志信息私密


### 10. 致谢


### 11. 引用
### 11.1 规范引用
### 11.2 信息引用

### 附录A：HTTP 版本历史
### A.1 从 HTTP/1.0 后的改变
### A.1.1 多宿主网页服务
### A.1.2 持久连接
### A.1.3 传输编码介绍
### A.2 从 RFC 2616 后的改变

### 附录B：ABNF 集合