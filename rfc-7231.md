### RFC 7231 Semantic and Content

### 备忘录状态

### 版权注意

### 1. 介绍
每一个超文本传输协议（HTTP）信息要么是一个请求，要么是一个响应。一个服务端在在一个连接上监听请求，转化每一个接收到的消息，解释和表示请求目标相关的消息语义，并使用一个或者多个响应消息响应请求。一个客户端构造请求消息去传达特定意图，检查接受到的响应意图是否被执行，并决定如何解释结果。这个文档使用 [RFC7230] 定义的术语定义了 HTTP/1.1 请求和响应语义。

HTTP 提供了一个和资源（章节 2）交互的通用接口，无视它的类型，性质，或者实现，通过操作和传输表现（章节 3）。

HTTP 语义包括每一个请求方法定义的意图（章节 4），这些语义的扩展可能描述在请求头部域（章节 5），状态码指定的机器可读响应的意义（章节 6），和其他阿控制数据和资源元数据的意义可能在响应头部域给出（章节 7）。

这文文档也定义了表现元数据，描述了一个负载期待如何被接收者处理，请求头部域可能影响内容选择，一系列选择算法集合引用为“内容协商”（章节 3.4）。

### 1.1 一致性和错误错误
### 1.2 语法符号

### 2. 资源
HTTP 请求的目标叫做“资源”。HTTP 不限制资源的性质；他仅仅定义了一个可能用来和资源交互接口。每一个资源使用统一资源标识符（URI），定义在 [RFC7230] 的章节 2.7。

当客户端构造一个 HTTP/1.1 请求消息，它使用各种格式中的一种发送目标 URI，定义在（[RFC7231] 的章节 5.3）。当接收到一个请求，服务端为目标资源重新构建一个有效请求 URI。

HTTP 的其中一个设计目标是从请求语义中分离资源资源表示，通过请求方法（章节 4）的请求语义和少量请求修改头部域（章节 5）可以实现。如果方法语义和 URI 自身暗示的语义冲突了，定义在章节 4.2.1，方法语义优先。

### 3. 表现
考虑到一个资源可以是任何东西，并且 HTTP 提供的通用接口类似一个窗口，通过它可以观察和处理这类东西，只能通过另一端独立的参与者交流信息，一个抽象需要表示（“代替”）当前或者期望的状态，在我们的交流中的这个东西。这个抽象叫做表现 [REST]。


因为 HTTP 的目的，一个“表现”是一个反映给定资源过去，当前，或者期望的状态的信息，以通过协议可信通行的格式，它由一些列表现元数据和一个潜在的无限的表现数据。

一个源服务端可能提供，或者可以被生成，多个表现，每一个用于反映目标资源的当前状态。在这类场景中，一些算法被源服务器用来选择其中的一个表现，最适用于给定请求，通常基于内容协商。这个“选择的表现”用来为评估条件请求 [RFC7232] 和构造 200（OK）和 304（Not Modified）GEt 响应负载提供数据和元数据。

### 3.1 表现元数据
表现头部域提供表现相关的元数据。当消息包含负载体，表现头部域描述如何解释负载体内的表现数据。在 HEAD 请求的响应中，表现头部域描述如果相同的请求是 GET，已经封闭在负载体内的表现数据。

下面的头部域覆盖了表现元数据：

| 头部域名 | 定义在 |
| - | - |
| Content-Type | 章节 3.1.1.5 |
| Content-Encoding | 章节 3.1.2.2 |
| Content-Language | 章节 3.1.3.2 |
| Content-Location | 章节 3.1.4.2 |

### 3.1.1 处理表现数据
### 3.1.1.1 媒体类型

HTTP 在 Content-Type（章节 3.1.1.5）和 Accept（章节 5.3.2）头部域使用互联网媒体类型 [RFC2046]，为了提供开放和可扩展的数据类型和内容协商。媒体类型定义了一个数据格式和一系列的处理模型：怎样处理数据根据接收它的每一个上下文。
```
    media-type  = type "/" subtype * ( OWS ";" OWS parameter )
    type        = token
    subtype     = token
```

type/subtype 后面可能跟着 name=value 对格式的参数。
```
    parameter   = token "=" ( token / quoted-string )
```
type， subtype，和参数名令牌是大小写不敏感的，参数值可能或者可能不是大小写敏感，依赖于参数名的语义。参数的存在或者不存在对于媒体类型的处理可能非常重要，依赖于他在媒体类型注册的定义。

一个参数值匹配令牌产生式可以被传输为一个令牌或者在引用字符串内。引用或者不引用的值都是相等的。比如下面的栗子全是相同的，但是第一个是一致性首选。
```
    text/html;charset=utf-8
    text/html;charset=UTF-8
    text/html;charset="utf-8"
    text/html; charset="utf-8"
```

互联网媒体类型可能定义在 IANA，基于定义在 [BCP13] 的产生式。

注意：不像其他头部域的构建方式，媒体类型参数不允许在“=”字符周围有空格（甚至是“坏的”空白）。

### 3.1.1.2 字符集
HTTP 使用字符集名称去指定或者协商一个文字表现的字符编码方案 [RFC6365]。一个字符集使用大小写不敏感的令牌标识
```
    charset = token
```
字符集名字应该被注册在 IANA 的“字符集合”注册（<http://www.iana.org/assignments/character-sets>），基于定义在 [RFC2978] 的产生式。

### 3.1.1.3 规范化和默认文本
互联网媒体类型使用规范化的格式注册，为了在多种本地编码格式的系统中互相操作。通过 HTTP 选择或者传输的表现应该以规范化的格式，由于许多相同的原因，描述在多目的互联网邮件扩展（MIME）[RFC2045]。然而，邮件部署的性能特性和 普通的 HTTP 和 Web（基于服务的信息服务） 有非常大的不同。甚至，MIME为了兼容旧的邮件传输协议，限制在 HTTP MIME 的规范化格式中不允许应用 CRLF 作为“text”媒体子类型的文字断行。HTTP 允许使用纯 CR 或者 LF 表示换行符的文本媒体的传输，当这类换行符对于整个表现是一致的时候。一个 HTTP 发送者可能生成，一个接收者必须可以转化，文本媒体中的换行符，包括 CRLF，仅 CR， 或者仅 LF。此外，HTTP 的文本媒体不限制各自使用 13 和 10 八位位组的字符集来表示 CR 和 LF。这个灵活性无视换行符，只应用在表现被赋予“text”媒体类型的时候；它不应用于“multipart”类型后者在负载正文之外的 HTTP 元素（比如，头部域）。

如果一个表现使用内容编码编码，底层数据应该以前面的格式被编码。

### 3.1.1.4 多部分类型
MIME 提供了一些列的“多部分”类型 -- 封装一个或者多个表现到一个单独的消息正文。所有的多部分共享一个相同的语法，定义在  [RFC2046] 的章节 5.1.1，包含一个 boundary 参数作为媒体类型值的一部分。消息正文是它自己的一个协议元素；一个发送者必须只生成 CRLF 去表示正文部分的换行符。

HTTP 消息帧不使用多部分边界作为消息正文长度的指示符号，尽管它可能在实现生成或者处理负载的时候用到。比如，“multipart/form-data”类型通常用于在请求内运输数据，定义在 [RFC2388]，这个规格定义的 “multipart/byteranges”类型用于一些 206（Partial Content）响应 [RFC7233]。

### 3.1.1.5 Content-Type
“Content-TYpe”头部与指示关联的表现的媒体类型：封装在消息负载中的表现或者选择的表现，取决于消息语义。指定的媒体类型定义了数据格式，以及数据希望如何被接收者处理，在接收消息语义的范围内，在 Content-Encoding 指定的编码被解码之后。
```
    Content-Type = media-type
```
媒体类型定义在章节 3.1.1.1。这个域的一个栗子：
```
    Content-Type: text/html; charset=ISO-8859-4
```
一个发送者生成一个包含负载正文的消息应该生成一个 Content-Type 头部域在消息中，除非封装的表现的目标媒体类型对于发送者是未知的。如果 Content-Type 头部域不存在，接收者可能假设一个媒体类型“application/octet-stream”（[RFC2046]， 章节 4.5.1） 或者检查数据以确定它的类型。

在实践中，资源的拥有者并不总是会合适的配置他们的源服务器为给定表现提供一个正确的 Content-Type，结果，一些客户端会检查一个负载的内容，然后覆盖指定的类型。客户端这么做可能会得出错误的结论，可能保留额外的安全风险（比如，权限升级）。甚至，检查数据格式无法决定发送者的意图：很多数据格式匹配多种媒体类型，他们的区别只有语义。鼓励实现提供一个禁用此类“内容嗅探”的手段。

### 3.1.2 为了压缩或者简洁的编码
### 3.1.2.1 内容编码
内容编码值指定一个已经应用或者可以应用到一个表现的编码转化。内容编码主要用于允许一个表现去压缩或者其他有用转化而不丢失信息。通常，表现存储在编码格式，直接运输，然后在最红接收者那解码。
```
    content-coding  = token
```
所有的内容编码值是大小写不敏感的，应该在“HTTP 内容编码注册”中注册，定义在章节 8.4。他们用在 Accept-Encoding（章节 5.3.4）和 Content-Encoding（章节 3.1.2.2）头部域。

下列是这个规格定义的内容编码值：
```
    compress（和 x-compress）：查看 [RFC7230] 的章节 4.2.1
    deflate：查看 [RFC7230] 的章节 4.2.2
    gzip（和 x-gzip）：查看 [RFC7230] 的章节 4.2.3
```
### 3.1.2.2 内容编码
“Content-Encoding”头部域指示应用什么内容编码到表现，在媒体类型固有之上，和什么解码机制应该被应用于去获取 Content-Type 头部域指定的媒体类型的数据。Content-Encoding 主要用于允许压缩表现的数据而不丢失底层媒体类型的标识。
```
    Content-Encoding    = 1#content-coding
```
一个它使用的栗子：
```
    Content-Encoding: gzip
```
如果一个或者多个编码被应用于表现，应用编码的发送者必须生成 Content-Encoding 头部域，并按顺序列出应用的编码。额外关于编码参数的信息可以通过其他不在这个规格定义的头部域提供。

不像 Transfer-Encoding（[RFC7230] 的章节 3.3.1），Content-Encoding 中列出的编码是表现的特征；表现定义为编码格式，所有其他表现的元数据是关于编码形式的，除非标志是元数据定义。通常，表现通常在渲染或者类似使用之前才解码。

如果媒体类型包含一个固有的编码，比如一个数据格式总是被压缩的，那么这个编码不能在 Content-Encoding 中被重申，就算他和其中一个内容编码的算法一致。这样一个内容编码只能被列出，因为一些奇怪的原因，它被第二次应用于组织表现。同样的，服务端可能选择去发布相同的数据，作为多个表现，它们的不同之处仅仅在于编码是否定义为 Content-Type 或者 Content-Encoding 的一部分，因为一些用户代理在每一个响应的处理都不同（比如，打开一个“另存为...”弹唱替代自动解压和渲染内容）。

一个源服务端可能响应一个 405（Unsupported Media Type）状态码，如果一个请求消息中的表现有一个不被接收的内容编码。


### 3.1.3 观众语言
### 3.1.3.1 语言标签
一个语言标签，定义在 [RFC5646]，标志一个自然语言，说，写，或者其他覆盖人类和其他人类信息交流。计算机语言明确的排除。

HTTP 在 Accept-Language 和 Content-Language 头部域内使用语言标签。Accept-Language 使用广阔的语言范围产生式，定义在占个鸡 5.3.5，然而，Content-Language 使用定义在下面的语言标签产生式。
```
    language-tag    = <Language-Tag, 查看 [RFC5646] 的章节 2.1>
```
一个语言标签是一个或者多个大小写不敏感的子标签序列，每一个使用横杆字符（“-”，%x2D）分割。在大部分的场景中，一个语言标签由主语言子标签，它标识一个广泛的相关语言家族（比如，“en” = Engilish），后面可选的跟随一个系列的子标签，提炼和收缩语言的范围（比如，“en-CA” = 多样性的英语在加拿大使用）。空格不允许出现在语言标签中。标签栗子包含：
```
    fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
```
查看 [RFC5646] 了解更多信息。

### 3.1.3.2 Content-Language
“Content-Type”头部域名描述了表现的目标观众的自然语言。注意这可能和表现内使用的语言完全一样。
```
    Content-Type    = 1#language-tag
```
定义在章节 3.1.3.1 的语言标签。Content-Language 的主要目的是允许一个用户使用用户自己偏爱的语言去标识和区分表现。因此，如果内容只为了服务一个 Danish-literate guanzh，合适的值是：
```
    Content-Language: da
```
如果没有指定 Content-Language，默认认为内容目标是所有观众。这可能意味着发送者没有考虑到指定它为任何自然语言，或者发送者不知道哪一个语言是目标。

多语言可能为内容列出为了服务多中观众。比如一个“怀唐伊条约”演出，同时以 Maori 和 English 版本，会调用
```
    Content-Language: mi, en
```
然而，只因为一个表现内使用多种语言来表示不意味着用于多语言观众。一个栗子可以是初学者的语言入门，这样一个“A First Lesson in Latin”，很明显用于一个英语语种的观众。在这个场景中，Content-Language 合适的值值包含“en”。

Content-Language 可以应用于任何媒体类型 --  他不局限于文本文档。


### 3.1.4 标识
### 3.1.4.1 识别表现
当一个完整或者部分的表现在消息负载中被传输，通常期望一个发送者去支持，或者接收者去决定，一个标识符用来表示资源相符的表现

对于一个请求消息：
- 如果请求有一个 Content-Location 头部域，则发送者断言负载是一个资源的表现，通过 Content-Location 域值。然而。这样一个断言不能被信任，除非他可以通过其他手段（不在这个规格内定义）。信息可能依旧对修改历史连接有用。
- 否则，负载是不可识别的。

对于一个响应消息，下面的规则依次应用，直到匹配：
1. 如果请求方式是 GET 或者 HEAD，并且响应状态码是 200（OK），204（No Content），206（Partical Content），或者 304（未定义），负载是资源的表现，通过有效请求 URI（[RFC7230] 的章节 5.5）识别。

2. 如果请求方式是 GET 或者 HEAD，并且响应状态码是 203（Non-Authority Infomation），负载是中介提供的目标资源的一个潜在的修改或者增强的表现。

3. 如果响应有一个 Content-Location 头部域，并且它的域值是和有效请求 URI 相同的 URI 引用，则负载是资源的表现，通过有效请求 URI 识别。

4.  如果响应有一个 Content-Location 头部域，并且它的域值是和有效请求 URI 不相同的 URI 引用，则发送者断言这个负载是资源的表现，通过 Content-Location 域值识别。然而，这样一个断言不能被信任，除非可以通过其他手段验证（不在这个规格内定义）

5. 否则，负载是不可识别的。

### 3.1.4.2 Content-Location

“Content-location”头部域引用一个 URI 可以作为一个指定资源的表示，表示消息负载中的表现。换句话说，如果一个 GET 请求在这个 URI 上执行，当这个消息生成的时候，则一个 200（OK）响应将会包含相同的表现封装在消息的负载里。
```
    Content-Location    = absolute-URI / partial-URI
```
Content-Location 值不是有效请求 URI 的替代（[RFC7230] 的章节 5.5）。它是表现元数据。它和定义在 [RFC2557] 章节 4 的 MIME 正文部分相同名字的头部域有相同的语法和语义。然而，他出现在一个 HTTP 消息对于 HTTP 接收者有一些特殊暗示。

如果 Content-Location 在一个 2xx（Successful）响应消息中，他的值引用一个 URI，和有效请求 URI 相同，则接收者可能认为负载是当前资源的表现，在消始发日期指定的时间。对于一个 GET（章节 4.3.1）或者 HEAD（章节 4.3.2）请求，这和默认语义相同，当服务端没有提供 Content-Location。对于一个状态改变请求，比如 PUT（章节 4.3.4）和 POST（章节 4.3.3），他意味着服务端响应包含这个资源的新表现，因此从表现中区分它值和动作的报告有关（比如，“It worked”）。这允许认证应用去更新他们本地复制，而不需要接下来的 GET 请求。

如果 Content-Location 包含在一个 2xx（Successful）响应消息，并且它的域值引用的 URI 和有效请求 URI 不同，则域服务器声称 URI 是一个不同资源的标识符，和封装的表现相符。这么一个声明只有在标识符分享相同的资源拥有者可信，这无法通过 HTTP 程序化决定。

- 对于一个 GET 或者 HEAD 请求的响应，这是一个有效 URI 引用资源的标识，它是内容协商的主题，Content-Location 域值是选中表现的更特殊的标识。

- 对于一个状态改变方法的 201（Created）响应，Content-Location 域值和 Location 域值相同，负载是新创建资源的当前表现。

- 否则，这么一个 Content-Location 指示这个负载是请求动作的状态报告的表现，并且可以从给定的 URI 得到相同的报告（将来使用 GET 访问）。比如，一个通过一个 POST 请求生成的采购交易可能包含接收到的文档作为 200（OK）响应的负载；Content-Location 域值提供一个在未来获取相同接收的拷贝标识。

一个用户代理在请求消息中发送 Content-Location 标识它的值引用用户代理原始获取封装表现的内容（在被用户代理修改之前）。换句话说，用户代理提供一个返回原始表现资源的链接。

一个源服务器接收到一个包含 Content-Location 域的请求消息必须对待消息类似临时上下文，而不是保存为表现一部分的元数据。一个源服务器可能使用这个上下文去引导处理请求，或者为其他使用保存它，比如，源链接或者版本控制元数据。然而，一个源服务必须不使用这样的上下文信息去修改请求语义。

比如，入股一个客户端创建一个 PUT 请求在一个协商资源，并且源服务接收 PUT（没有重定向），则资源的新状态起期待和应用在 PUT 上的一致；Content-Location 不能用作反向内容选择标识符，去更新唯一的协商表现。如果用户代理想要后一种语义，它将直接应用 PUT 到 Content-Location URI。


### 3.2 表现数据
HTTP 消息关联的表现数据要么作为消息的负载正文提供，或者引用消息语义和有效请求 URI。表现数据以定义在表现元数据头部域编码的形式。

表现数据的数据类型通过头部域 Content-Type 和 Content-Encoding 决定。这定义了两层，排序编码模型：
```
    representation-data := Content-Encoding( Content-Type( bits ) )
```


### 3.3 负载语法

一些 HTTP 消息传输完整或者部分表现作为消息的“负载”。在一些场景中，一个负载可能只包含关联的表现的头部（比如，HEAD 的响应）或者只有表现的部分（比如，206（Partial Content）状态码）。

请求中负载的目标通过方法语义定义。比如，PUT 请求（章节 4.3.4）负载中的表现表示目标资源的期待状态，如果请求被成功应用，然而 POST 请求（章节 4.3.3）负载中的表现表示被目标资源处理的信息。

在响应中，负载的目标是被请求方法和响应状态码定义的。比如，GET（章节 4.3.1）的 200（OK）的负载表示当前目标资源的状态，在消息始发日期（章节 7.1.1.2）观察到的，然而，有相同状态码的 POST 的响应的负载可能表示处理结果或者应用处理之后目标资源的新状态。错误状态码的响应消息通常包含一个负载，表示一个错误条件，他描述错误状态和拓建下一步如何做去处理它。

指定迎来描述负载的头部域，预期说关联表现，更像用作“负载头部域”。负载头部域定义在这个规格的其他部分，因为他们影响消息转化。

| 头部域名字 | 定义在 |
| - | - |
| Content-Length | [RFC7230]的章节 3.3.2 |
| Content-Range | [RFC7233]的章节 4.2 |
| Trailer | [RFC7230]的章节 4.4 |
| Transfer-Encoding | [RFC7230]的章节 3.3.1 |

### 3.4 内容协商

当响应表达负载信息的时候，只是一个成功或者失败，源服务器通常有不同的方式表示信息；比如，不同的格式，语言，或者编码。同样的，不同的用户或者用户代理可能有不同的能力，字符，或者偏好，可以影响表现，在这些可用的，最好提供。因为这个原因，HTTP 提供内容协商的机制。

这个规格定义了两种模式的内容协商，可以在协议中可见：“主动协商”，服务端基于用户代理的偏好选择表现，“响应”协商，服务端为用户代理提供表现列表以供选择。其他模式的内容协商包括“条件内容”，由多个部分构成的表现选择性的基于用户代理参数渲染，“活跃内容”，表现包含一个脚本创建额外（更加特殊）的请求，基于用户代理的性质，“透明内容协商”（[RFC2295]），内容选择是中介执行的。这些模式不是相互排除的，每一个都在实用性和适用性之间权衡。

注意：在所有的场景中，HTTP 没有意识到资源语义。源服务器对请求的响应的一致性，跨越时间和内容协商的尺寸，因此，锁着时间，资源的可观察的表现的“相同性”完全决定于实体或者算法选择，或者生成这些响应。HTTP 不注意幕后的人。

### 3.4.1 主动协商
鼓励服务端的算法选择偏好的表现，叫做主动协商（也叫做，服务端驱动的协商）。选择基于响应可用的表现（他可能会编码的会读，比如语言，内容编码，等），和应用在请求中的各种信息相比，包括章节 5.3 明确的协商域，和暗示特性，比如客户端的网络地址或者用户代理域的一部分。

主动协商是有利地，当用来从可用表现选择的算法很难描述用户代理，后者当服务端期望去发送它的第一个“最佳猜测”响应（希望避免后续请求的往返循环延迟，如果“最佳猜测”对于用户足够好）到用户代理。为了提高服务端猜测，用户代理可能在请求中发送描述它的偏好的头部域。

主动协商有一系列的缺陷：

### 3.4.2 响应协商
### 4. 请求方法
### 4.1 概述
### 4.2 普通方法属性
### 4.3 方法定义


### 5. 请求头域
### 5.1 控制
### 5.2 条件
### 5.3 内容协商
### 5.4 认证凭证
### 5.5 请求上下文


### 6. 响应状态码
### 6.1 状态码概述
### 6.2 信息 1xx
### 6.3 成功 2xx
### 6.4 重定向 3xx
### 6.5 客户端错误 4xx
### 6.6 服务端错误 5xx


### 7. 响应头域
### 7.1 控制数据
### 7.2 验证头部域
### 7.3 认证邀请
### 7.4 响应上下文


### 8. IANA 注意事项
### 8.1 方法注册
### 8.2 状态码注册
### 8.3 头部域注册
### 8.4 内容码注册


### 9. 安全注意事项
### 9.1. 基于文件和路径名的攻击
### 9.2. 基于命令，码，或者查询注入的攻击
### 9.3. 个人信息披露
### 9.4. URI 中敏感信息披露
### 9.5. 重定向后片段披露
### 9.6. 产品信息披露
### 9.7. 浏览器指纹

### 10. 致谢

### 11. 引用

### 附录 A. HTTP 和 MIME 之间的不同

### 附录 B. RFC 2616 之后的改变

### 附录 C. 导入的 ABNF

### 附录 D. ABNF 集合