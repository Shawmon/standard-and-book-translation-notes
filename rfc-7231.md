### RFC 7231 Semantic and Content

### 备忘录状态

### 版权注意

### 1. 介绍
每一个超文本传输协议（HTTP）信息要么是一个请求，要么是一个响应。一个服务端在在一个连接上监听请求，转化每一个接收到的消息，解释和表示请求目标相关的消息语义，并使用一个或者多个响应消息响应请求。一个客户端构造请求消息去传达特定意图，检查接受到的响应意图是否被执行，并决定如何解释结果。这个文档使用 [RFC7230] 定义的术语定义了 HTTP/1.1 请求和响应语义。

HTTP 提供了一个和资源（章节 2）交互的通用接口，无视它的类型，性质，或者实现，通过操作和传输表现（章节 3）。

HTTP 语义包括每一个请求方法定义的意图（章节 4），这些语义的扩展可能描述在请求头部域（章节 5），状态码指定的机器可读响应的意义（章节 6），和其他阿控制数据和资源元数据的意义可能在响应头部域给出（章节 7）。

这文文档也定义了表现元数据，描述了一个负载期待如何被接收者处理，请求头部域可能影响内容选择，一系列选择算法集合引用为“内容协商”（章节 3.4）。

### 1.1 一致性和错误错误
### 1.2 语法符号

### 2. 资源
HTTP 请求的目标叫做“资源”。HTTP 不限制资源的性质；他仅仅定义了一个可能用来和资源交互接口。每一个资源使用统一资源标识符（URI），定义在 [RFC7230] 的章节 2.7。

当客户端构造一个 HTTP/1.1 请求消息，它使用各种格式中的一种发送目标 URI，定义在（[RFC7231] 的章节 5.3）。当接收到一个请求，服务端为目标资源重新构建一个有效请求 URI。

HTTP 的其中一个设计目标是从请求语义中分离资源资源表示，通过请求方法（章节 4）的请求语义和少量请求修改头部域（章节 5）可以实现。如果方法语义和 URI 自身暗示的语义冲突了，定义在章节 4.2.1，方法语义优先。

### 3. 表现
考虑到一个资源可以是任何东西，并且 HTTP 提供的通用接口类似一个窗口，通过它可以观察和处理这类东西，只能通过另一端独立的参与者交流信息，一个抽象需要表示（“代替”）当前或者期望的状态，在我们的交流中的这个东西。这个抽象叫做表现 [REST]。


因为 HTTP 的目的，一个“表现”是一个反映给定资源过去，当前，或者期望的状态的信息，以通过协议可信通行的格式，它由一些列表现元数据和一个潜在的无限的表现数据。

一个源服务端可能提供，或者可以被生成，多个表现，每一个用于反映目标资源的当前状态。在这类场景中，一些算法被源服务器用来选择其中的一个表现，最适用于给定请求，通常基于内容协商。这个“选择的表现”用来为评估条件请求 [RFC7232] 和构造 200（OK）和 304（Not Modified）GEt 响应负载提供数据和元数据。

### 3.1 表现元数据
表现头部域提供表现相关的元数据。当消息包含负载体，表现头部域描述如何解释负载体内的表现数据。在 HEAD 请求的响应中，表现头部域描述如果相同的请求是 GET，已经封闭在负载体内的表现数据。

下面的头部域覆盖了表现元数据：

| 头部域名 | 定义在 |
| - | - |
| Content-Type | 章节 3.1.1.5 |
| Content-Encoding | 章节 3.1.2.2 |
| Content-Language | 章节 3.1.3.2 |
| Content-Location | 章节 3.1.4.2 |

### 3.1.1 处理表现数据
### 3.1.1.1 媒体类型

HTTP 在 Content-Type（章节 3.1.1.5）和 Accept（章节 5.3.2）头部域使用互联网媒体类型 [RFC2046]，为了提供开放和可扩展的数据类型和内容协商。媒体类型定义了一个数据格式和一系列的处理模型：怎样处理数据根据接收它的每一个上下文。
```
    media-type  = type "/" subtype * ( OWS ";" OWS parameter )
    type        = token
    subtype     = token
```

type/subtype 后面可能跟着 name=value 对格式的参数。
```
    parameter   = token "=" ( token / quoted-string )
```
type， subtype，和参数名令牌是大小写不敏感的，参数值可能或者可能不是大小写敏感，依赖于参数名的语义。参数的存在或者不存在对于媒体类型的处理可能非常重要，依赖于他在媒体类型注册的定义。

一个参数值匹配令牌产生式可以被传输为一个令牌或者在引用字符串内。引用或者不引用的值都是相等的。比如下面的栗子全是相同的，但是第一个是一致性首选。
```
    text/html;charset=utf-8
    text/html;charset=UTF-8
    text/html;charset="utf-8"
    text/html; charset="utf-8"
```

互联网媒体类型可能定义在 IANA，基于定义在 [BCP13] 的产生式。

注意：不像其他头部域的构建方式，媒体类型参数不允许在“=”字符周围有空格（甚至是“坏的”空白）。

### 3.1.1.2 字符集
HTTP 使用字符集名称去指定或者协商一个文字表现的字符编码方案 [RFC6365]。一个字符集使用大小写不敏感的令牌标识
```
    charset = token
```
字符集名字应该被注册在 IANA 的“字符集合”注册（<http://www.iana.org/assignments/character-sets>），基于定义在 [RFC2978] 的产生式。

### 3.1.1.3 规范化和默认文本
互联网媒体类型使用规范化的格式注册，为了在多种本地编码格式的系统中互相操作。通过 HTTP 选择或者传输的表现应该以规范化的格式，由于许多相同的原因，描述在多目的互联网邮件扩展（MIME）[RFC2045]。然而，邮件部署的性能特性和 普通的 HTTP 和 Web（基于服务的信息服务） 有非常大的不同。甚至，MIME为了兼容旧的邮件传输协议，限制在 HTTP MIME 的规范化格式中不允许应用 CRLF 作为“text”媒体子类型的文字断行。HTTP 允许使用纯 CR 或者 LF 表示换行符的文本媒体的传输，当这类换行符对于整个表现是一致的时候。一个 HTTP 发送者可能生成，一个接收者必须可以转化，文本媒体中的换行符，包括 CRLF，仅 CR， 或者仅 LF。此外，HTTP 的文本媒体不限制各自使用 13 和 10 八位位组的字符集来表示 CR 和 LF。这个灵活性无视换行符，只应用在表现被赋予“text”媒体类型的时候；它不应用于“multipart”类型后者在负载正文之外的 HTTP 元素（比如，头部域）。

如果一个表现使用内容编码编码，底层数据应该以前面的格式被编码。

### 3.1.1.4 多部分类型
MIME 提供了一些列的“多部分”类型 -- 封装一个或者多个表现到一个单独的消息正文。所有的多部分共享一个相同的语法，定义在  [RFC2046] 的章节 5.1.1，包含一个 boundary 参数作为媒体类型值的一部分。消息正文是它自己的一个协议元素；一个发送者必须只生成 CRLF 去表示正文部分的换行符。

HTTP 消息帧不使用多部分边界作为消息正文长度的指示符号，尽管它可能在实现生成或者处理负载的时候用到。比如，“multipart/form-data”类型通常用于在请求内运输数据，定义在 [RFC2388]，这个规格定义的 “multipart/byteranges”类型用于一些 206（Partial Content）响应 [RFC7233]。

### 3.1.1.5 Content-Type
“Content-TYpe”头部与指示关联的表现的媒体类型：封装在消息负载中的表现或者选择的表现，取决于消息语义。指定的媒体类型定义了数据格式，以及数据希望如何被接收者处理，在接收消息语义的范围内，在 Content-Encoding 指定的编码被解码之后。
```
    Content-Type = media-type
```
媒体类型定义在章节 3.1.1.1。这个域的一个栗子：
```
    Content-Type: text/html; charset=ISO-8859-4
```
一个发送者生成一个包含负载正文的消息应该生成一个 Content-Type 头部域在消息中，除非封装的表现的目标媒体类型对于发送者是未知的。如果 Content-Type 头部域不存在，接收者可能假设一个媒体类型“application/octet-stream”（[RFC2046]， 章节 4.5.1） 或者检查数据以确定它的类型。

在实践中，资源的拥有者并不总是会合适的配置他们的源服务器为给定表现提供一个正确的 Content-Type，结果，一些客户端会检查一个负载的内容，然后覆盖指定的类型。客户端这么做可能会得出错误的结论，可能保留额外的安全风险（比如，权限升级）。甚至，检查数据格式无法决定发送者的意图：很多数据格式匹配多种媒体类型，他们的区别只有语义。鼓励实现提供一个禁用此类“内容嗅探”的手段。

### 3.1.2 为了压缩或者简洁的编码
### 3.1.2.1 内容编码
内容编码值指定一个已经应用或者可以应用到一个表现的编码转化。内容编码主要用于允许一个表现去压缩或者其他有用转化而不丢失信息。通常，表现存储在编码格式，直接运输，然后在最红接收者那解码。
```
    content-coding  = token
```
所有的内容编码值是大小写不敏感的，应该在“HTTP 内容编码注册”中注册，定义在章节 8.4。他们用在 Accept-Encoding（章节 5.3.4）和 Content-Encoding（章节 3.1.2.2）头部域。

下列是这个规格定义的内容编码值：
```
    compress（和 x-compress）：查看 [RFC7230] 的章节 4.2.1
    deflate：查看 [RFC7230] 的章节 4.2.2
    gzip（和 x-gzip）：查看 [RFC7230] 的章节 4.2.3
```
### 3.1.2.2 内容编码
“Content-Encoding”头部域指示应用什么内容编码到表现，在媒体类型固有之上，和什么解码机制应该被应用于去获取 Content-Type 头部域指定的媒体类型的数据。Content-Encoding 主要用于允许压缩表现的数据而不丢失底层媒体类型的标识。
```
    Content-Encoding    = 1#content-coding
```
一个它使用的栗子：
```
    Content-Encoding: gzip
```
如果一个或者多个编码被应用于表现，应用编码的发送者必须生成 Content-Encoding 头部域，并按顺序列出应用的编码。额外关于编码参数的信息可以通过其他不在这个规格定义的头部域提供。

不像 Transfer-Encoding（[RFC7230] 的章节 3.3.1），Content-Encoding 中列出的编码是表现的特征；表现定义为编码格式，所有其他表现的元数据是关于编码形式的，除非标志是元数据定义。通常，表现通常在渲染或者类似使用之前才解码。

如果媒体类型包含一个固有的编码，比如一个数据格式总是被压缩的，那么这个编码不能在 Content-Encoding 中被重申，就算他和其中一个内容编码的算法一致。这样一个内容编码只能被列出，因为一些奇怪的原因，它被第二次应用于组织表现。同样的，服务端可能选择去发布相同的数据，作为多个表现，它们的不同之处仅仅在于编码是否定义为 Content-Type 或者 Content-Encoding 的一部分，因为一些用户代理在每一个响应的处理都不同（比如，打开一个“另存为...”弹唱替代自动解压和渲染内容）。

一个源服务端可能响应一个 405（Unsupported Media Type）状态码，如果一个请求消息中的表现有一个不被接收的内容编码。


### 3.1.3 观众语言

### 3.1.4 标识

### 3.2 表现数据
### 3.3 负载语法
### 3.4 内容协商


### 4. 请求方法
### 4.1 概述
### 4.2 普通方法属性
### 4.3 方法定义


### 5. 请求头域
### 5.1 控制
### 5.2 条件
### 5.3 内容协商
### 5.4 认证凭证
### 5.5 请求上下文


### 6. 响应状态码
### 6.1 状态码概述
### 6.2 信息 1xx
### 6.3 成功 2xx
### 6.4 重定向 3xx
### 6.5 客户端错误 4xx
### 6.6 服务端错误 5xx


### 7. 响应头域
### 7.1 控制数据
### 7.2 验证头部域
### 7.3 认证邀请
### 7.4 响应上下文


### 8. IANA 注意事项
### 8.1 方法注册
### 8.2 状态码注册
### 8.3 头部域注册
### 8.4 内容码注册


### 9. 安全注意事项
### 9.1. 基于文件和路径名的攻击
### 9.2. 基于命令，码，或者查询注入的攻击
### 9.3. 个人信息披露
### 9.4. URI 中敏感信息披露
### 9.5. 重定向后片段披露
### 9.6. 产品信息披露
### 9.7. 浏览器指纹

### 10. 致谢

### 11. 引用

### 附录 A. HTTP 和 MIME 之间的不同

### 附录 B. RFC 2616 之后的改变

### 附录 C. 导入的 ABNF

### 附录 D. ABNF 集合